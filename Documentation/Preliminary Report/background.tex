\chapter{Background Survey}\label{chapter:background}

%This should discuss any existing solutions to the given problem, and may reference academic papers, books and other sources as appropriate. Care should be taken to identify key differences between these solutions, and that being developed in the project.

There exists a number of different test-case generation tools for different languages such as QuickCheck for Haskell, Quviq QuickCheck for Erlang, Concolic Unit Testing Engine (CUTE) for C and Randoop for Java and .NET.


QuickCheck for Whiley is specifically created for the Whiley programming language.
Another key difference while making QuickCheck for Whiley is that different techniques are used to generate test data instead of just one technique.

% Something about Whiley, verification and formal specs
% TODO 
\section{Whiley}
Whiley is a hybrid imperative and functional programming language developed by David Pearce.

A notable aspect about Whiley is the verifying compiler used in conjunction with explicit specifications to verify programs are correct.


Whiley files are compiled with or without static verification into a WyIL file which is a binary form of the Whiley program in an intermediate language.

% Talk about theorem prover?

% Talk about the data types that exist?

%Formal specifications are built into Whiley

\section{QuickCheck}
QuickCheck is a tool implemneted by Koen Claessen and John Hughes \cite{QClightweight} to test Haskell programs.

To check if a program is correct, QuickCheck uses property-based testing which uses conditions that will always hold true. Users define the conditions as Haskell functions in terms of formal specifications to validate functions under test. 

QuickCheck then generates a large number of test cases automatically using random testing. Input values are randomly generated for each test (within a range) using generators that correspond to the input value's type. QuickCheck contains generators for most of Haskell's predefined types and for functions. User-defined types require the tester to specify their own custom generators with a bounded size if the type is recursive such as a binary tree. \cite{QClightweight}. 

A problem with random testing is the distribution of test data. Ideally, the distribution should adhere to the distribution of actual data which is often uniformly distributed. For example, executing tests for Listing \ref{lst:quickcheckExecute} could be skewed towards test data with short lists. The distribution of data is controlled by the tester by creating a custom generator for the data type with weighted frequencies on the methods used to generate the data.

An example of using QuickCheck would be reversing a list.

Firstly, a property is defined in Listing \ref{lst:quickcheckProperty} where the list xs, should be the same as reversing xs twice.

\begin{lstlisting}[language=haskell, label={lst:quickcheckProperty}, caption={Property for reversing a list in QuickCheck}]
propReverseTwice xs = reverse (reverse xs) == xs
\end{lstlisting}

QuickCheck is then executed by importing the property and passing it into the interpreter as shown in Listing \ref{lst:quickcheckExecute}

\begin{lstlisting}[label={lst:quickcheckExecute}, caption={Executing tests to check a list is reversed}]
Main:> quickCheck propReverseTwice
Ok: passed 100 tests.
\end{lstlisting}

This will create a large number of test cases by using the user-defined property and random input values to check the property holds. QuickCheck reports various test statistics including the number of tests that have passed or failed \cite{QClightweight}.

% Shrinking?

\section{Concolic Unit Testing Engine (CUTE)}
Concolic Unit Testing Engine (CUTE) generates test inputs using a combination of symbolic and concrete execution \cite{CUTE}. The aim of CUTE is to provide input values to explore all feasible execution paths of a program and thus achieve high path coverage \cite{CUTE}. CUTE has been applied to C programs \cite{CUTE}.

Random testing may generate inputs with the same behaviour leading to its redundancy \cite{CUTE}. Furthermore, the probability of selecting inputs that will detect errors using random testing is small \cite{CUTE}. 
Therefore, CUTE incrementally generates concrete inputs using symbolic execution to discover feasible paths \cite{CUTE}.

Firstly, CUTE executes the program with arbitrary inputs using concrete and symbolic execution concurrently \cite{CUTE}.
In concrete execution, the program is executed normally with the input values \cite{CUTE}. At the same time, symbolic execution is run through the same path. Using the symbolic variables, constraints from branching expressions are discovered and stored \cite{CUTE}. The last constraint applied is negated so that the next test run will explore a different feasible path \cite{CUTE}. The constraint is solved to limit and determine the possible inputs to execute in the next test \cite{CUTE}.

\section{Randoop}
Randoop generates unit tests using feedback-directed random test generation \cite{randoopAll}, \cite{randoopJava}. Method sequences from previous tests are used to help generate subsequent tests \cite{randoopAll}, \cite{randoopJava}.
As a result, a test suite is outputted with successful and unsuccessful tests \cite{randoopAll}, \cite{randoopJava}.

Randoop tests classes by executing a sequence of methods as a test \cite{randoopJava}. Method sequences are created incrementally by randomly selecting method calls and using arguments from previous sequences \cite{randoopJava}.
The sequence is then executed and checked against contracts \cite{randoopAll}.
Contracts are built into Randoop or optionally defined by the user \cite{randoopAll}.
If a sequence breaks a contract then the test is outputted as a contract-violating test \cite{randoopAll}. If sequence was successful, then the test is outputted as a regression test \cite{randoopAll}.
Successful sequences that can be extended or are not redundant are then used in subsequent tests \cite{randoopAll}.

%A commercial version of QuickCheck in Erlang called Quviq QuickCheck is co-founded by one of the original developers, John Hughes and is an extension of the original QuickCheck for Haskell \cite{QCFunProfit}.

% Quviq QuickCheck? Erlang
% Randoop
% Symbolic regression and other techniques?
% JCrasher?
% CUTE