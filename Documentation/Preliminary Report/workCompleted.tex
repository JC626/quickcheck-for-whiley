\chapter{Work Completed}\label{chapter:work}

%This should discuss what progress has been made on designing, implementing and evaluating the artifact. Care must be taken to ensure that any discussion of technical points are clearly explained, with diagrams being used where appropriate.
%In many cases, the evaluation proper will not yet have begun. However, it is important to demonstrate that sufficient thought has been given to the evaluation.

% Consideration of test generation techniques used
% Trade off => Performance vs accuracy?
% Needed to create test cases that adhered to the pre-conditon

An implementation of the tool has been created with generation of core and more complex data types. The tool has also been extended to use integer range analysis to constrain input values generated.

For a user to use the tool, a user must pass in a WyIL file and specify the test case generation technique to use, number of tests they wish to generate and ranges for generating integer values.
% TODO ranges
%Ranges are used to bound the integers generated to ...

The Whiley Theorem Prover is used to validate inputs and outputs from tests. Valid inputs based on verifying pre-conditions and constraints on the input type are used. A successful test is checked by using the function's post-condition and constraints on the output type.

Currently, only functions within the program with a post-condition are able to be tested as they can be verified.

\section{Test Case Generation Techniques}

QuickCheck for Whiley currently employs random test-case and exhaustive test case generation to generate test cases: 

\subsection{Random Test Case Generation}

A fixed number of tests determined by the user is randomly generated. Previous inputs are not considered which may lead to the same inputs being generated. 
% TODO refer Knuth Algorithm S
Algorithm ... was considered to generate unique inputs but has not been implemented yet.

\subsection{Exhaustive Test Case Generation}
A fixed number of tests determined by the user are exhaustively generated within a bounded range from the minimum bound to the maximum bound. All possible input combinations for a function are tested starting from the combination generated from the minimum bound.


% Talk about generators here
% Class diagram of the ranges
% Talk about the different types
\section{Data types generated}
Different generators are created for the different types defined in Whiley. 
Figure \ref{fig:qc-generators} illustrates the structure of the generators used.
Each generator generates a value. It also has a size for the number of input combinations and \texttt{resetCount()} and \texttt{exceedCount()} methods for monitoring input combinations generated for test-case generation.
 
\begin{figure}
	\caption{Class diagram of Generators in QuickCheck for Whiley}
	\label{fig:qc-generators}
	\includegraphics[width=\textwidth]{qc-generators}
	\centering
\end{figure}

\begin{description}
	\item[Null] Generate a \texttt{null} value.
	\item[Boolean] Generates a boolean which is either \texttt{true} or \texttt{false}.
	\item[Integer] Generates an integer between a bounded range. This range may be modified based on constraints applied to the integer.
	\item[Array] Generates an array with a specific element type between a bounded size range.
	The size of arrays are currently limited to a maximum size of three elements due to the performance cost of generating larger arrays.
	\item[Nominal] A nominal represents a user-defined type by redefining a type with a different name \cite{WhileyLang}. Therefore, a generator for a nominal wraps a generator for a different type to generate a value. A nominal can also have a type constraint/invariant applied to it \cite{WhileyLang}.
	\item[Record] "A record type describes the set of all compound values made from one or more fields, each of which has a unique name and a corresponding type \cite{WhileyLang}."
	A closed record is generated by generating values that correspond to each field. Generators corresponding to each field is required as each field may have different types. % Open records which can any number of fields with different types have not been implemented.
	% TODO Open records have not been implemented
	\item[Union] A union is made up of multiple types where the value can correspond to any one of the types declared. For example, the type \texttt{bool|int} can hold either a boolean or an integer value. 
	A union is generated by generating a value from one of the declared types. A generator corresponding to each type is required. 
	% Talk about fairness in union generation
	
	Values for the union type could be skewed towards generating values for only type. It was important that the different types for each union was fairly generated. Therefore, the union generator was implemented so that a value from a different type would be generated each time by iterating through the generators within the union generator.

\end{description}

\section{Integer Range Analysis}

% TODO complete properly!
Generating and checking for invalid inputs is costly in terms of performance. 
Therefore, it would be beneficial to reduce the number of invalid inputs generated and thus improve performance.
One method to remove invalid inputs for integers is to shrink the ranges used during generation thus no longer generate invalid inputs.

%For example, you have a type \texttt{type nat is (int x) where x >= 0} and test for an integer range between -5 and 5. Invalid inputs are numbers below 

% TODO create example to explain?
% TODO add link to integer range code 
This is implemented by evaluating the constraints within a nominal type to discover the integer range generated from the constraint. Existing code from ... was used to create the integer ranges. 
The integer range is then passed down in the nominal generator until it reaches the relevant integer or array generator. 
The ranges are then joined with the ranges within the generator to get the new range. 
If the ranges are invalid, i.e. the lower range is greater than the upper range then an error is thrown.
% TODO fix symbols
Integer ranges only work for constraints that follow the format of x op c where x is the named variable in the nominal type, op is an operator out of the set (<, <=. >=, > \&\&, ||, ==) and c is a constant number.

% Refer to paper 

\section{Evaluating the tool}
The tool has been evaluated by executing a variety of tests notably, the test suite for the Whiley Compiler.
%As a result, ... 
% Talk about how the tool is run
% Talk about evaluating the tool using the Whiley valid and invalid tests
% How to evaluate the tool